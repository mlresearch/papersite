@InProceedings{arora14,
  author = {Arora, Sanjeev and Ge, Rong and Moitra, Ankur},
  title = {New Algorithms for Learning Incoherent and Overcomplete Dictionaries },
  pages = {779-806},
  abstract = {In {\em sparse recovery} we are given a matrix $A \in \mathbb{R}^{n\times m}$ (``the dictionary'') and a vector of the form $A X$ where $X$ is {\em sparse}, and the goal is to recover $X$. This is a central notion in signal processing, statistics and machine learning. But in applications such as {\em sparse coding}, edge detection, compression and super resolution, the dictionary $A$ is unknown and has to be learned from random examples of the form $Y = AX$ where $X$ is drawn from an appropriate distribution --- this is the {\em dictionary learning} problem. In most settings, $A$ is {\em overcomplete}: it has more columns than rows. This paper presents a polynomial-time algorithm for learning overcomplete dictionaries; the only previously known algorithm with provable guarantees is the recent work of Spielman et al. (2012) who who gave an algorithm for the undercomplete case, which is rarely the case in applications. Our algorithm applies to {\em incoherent} dictionaries which have been a central object of study since they were introduced in seminal work of Donoho and Huo (1999). In particular, a dictionary is $\mu$-incoherent if each pair of columns has inner product at most $\mu / \sqrt{n}$.

The algorithm makes natural stochastic assumptions about the unknown sparse vector $X$, which can contain $k \leq c \min(\sqrt{n}/\mu \log n, m^{1/2 - \eta})$ non-zero entries (for any $\eta > 0$). This is close to the best $k$ allowable by the best sparse recovery algorithms  {\em even if one knows the dictionary $A$ exactly}. Moreover, both the running time and sample complexity depend on $\log 1/\epsilon$, where $\epsilon$ is the target accuracy, and so our algorithms converge very quickly to the true dictionary. Our algorithm can also tolerate substantial amounts of noise provided it is incoherent with respect to the dictionary (e.g., Gaussian). In the noisy setting, our running time and sample complexity depend polynomially on $1/\epsilon$, and this is necessary. },
}
